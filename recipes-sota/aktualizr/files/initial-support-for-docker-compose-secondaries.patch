From 841547841e337b80e9eaa406cbf2c47ab671cfa9 Mon Sep 17 00:00:00 2001
From: Phil Wise <phil@phil-wise.com>
Date: Thu, 3 Jan 2019 11:48:22 +0000
Subject: [PATCH] Initial support for docker-compose secondaries

Upstream-Status: Inappropriate [Torizon specific]

Signed-off-by: Phil Wise <phil@phil-wise.com>
Signed-off-by: Ming Liu <liu.ming50@gmail.com>
Signed-off-by: Stefan Agner <stefan.agner@toradex.com>
---
 .../docker-compose.json                       | 11 ++++++
 .../example-redis.yml                         |  5 +++
 src/libaktualizr/uptane/CMakeLists.txt        |  2 +
 src/libaktualizr/uptane/dockersecondary.cc    | 38 +++++++++++++++++++
 src/libaktualizr/uptane/dockersecondary.h     | 26 +++++++++++++
 src/libaktualizr/uptane/secondaryconfig.cc    |  2 +
 src/libaktualizr/uptane/secondaryconfig.h     |  1 +
 src/libaktualizr/uptane/secondaryfactory.h    |  3 ++
 src/libaktualizr/utilities/utils.cc           | 18 ++++++---
 src/libaktualizr/utilities/utils.h            |  7 ++--
 10 files changed, 105 insertions(+), 8 deletions(-)
 create mode 100644 config/docker-compose-secondaries/docker-compose.json
 create mode 100644 config/docker-compose-secondaries/example-redis.yml
 create mode 100644 src/libaktualizr/uptane/dockersecondary.cc
 create mode 100644 src/libaktualizr/uptane/dockersecondary.h

diff --git a/config/docker-compose-secondaries/docker-compose.json b/config/docker-compose-secondaries/docker-compose.json
new file mode 100644
index 00000000..1cba840c
--- /dev/null
+++ b/config/docker-compose-secondaries/docker-compose.json
@@ -0,0 +1,11 @@
+{
+  "secondary_type" : "docker_compose",
+  "partial_verifying" : "false",
+  "ecu_hardware_id" : "docker-compose",
+  "full_client_dir" : "storage/demo-vsec1",
+  "ecu_private_key" : "sec.private",
+  "ecu_public_key" : "sec.public",
+  "firmware_path" : "storage/demo-vsec1/docker.yml",
+  "target_name_path" : "storage/demo-vsec1/target_name",
+  "metadata_path" : "storage/demo-vsec1/metadata"
+}
diff --git a/config/docker-compose-secondaries/example-redis.yml b/config/docker-compose-secondaries/example-redis.yml
new file mode 100644
index 00000000..c9d8d554
--- /dev/null
+++ b/config/docker-compose-secondaries/example-redis.yml
@@ -0,0 +1,5 @@
+version: '3'
+services:
+  redis:
+    image: "redis:alpine"
+    restart: always
\ No newline at end of file
diff --git a/src/libaktualizr/uptane/CMakeLists.txt b/src/libaktualizr/uptane/CMakeLists.txt
index 4737b24f..f288944d 100644
--- a/src/libaktualizr/uptane/CMakeLists.txt
+++ b/src/libaktualizr/uptane/CMakeLists.txt
@@ -1,4 +1,5 @@
 set(SOURCES
+    dockersecondary.cc
     fetcher.cc
     ipsecondarydiscovery.cc
     ipuptanesecondary.cc
@@ -15,6 +16,7 @@ set(SOURCES
     virtualsecondary.cc)
 
 set(HEADERS
+    dockersecondary.h
     exceptions.h
     fetcher.h
     ipsecondarydiscovery.h
diff --git a/src/libaktualizr/uptane/dockersecondary.cc b/src/libaktualizr/uptane/dockersecondary.cc
new file mode 100644
index 00000000..6dc954a1
--- /dev/null
+++ b/src/libaktualizr/uptane/dockersecondary.cc
@@ -0,0 +1,38 @@
+#include "uptane/dockersecondary.h"
+
+#include "logging/logging.h"
+
+#include <sstream>
+
+using std::stringstream;
+
+namespace Uptane {
+DockerComposeSecondary::DockerComposeSecondary(const SecondaryConfig& sconfig_in) : ManagedSecondary(sconfig_in) {}
+
+bool DockerComposeSecondary::storeFirmware(const std::string& target_name, const std::string& content) {
+  Utils::writeFile(sconfig.target_name_path, target_name, true);
+  Utils::writeFile(sconfig.firmware_path, content, true);
+  stringstream cmd_line;
+  cmd_line << "docker-compose -f " << sconfig.firmware_path << " up -d";
+  LOG_INFO << " Running " << cmd_line.str();
+  int rescode = system(cmd_line.str().c_str());
+  return rescode == 0;
+}
+
+bool DockerComposeSecondary::getFirmwareInfo(std::string* target_name, size_t& target_len, std::string* sha256hash) {
+  std::string content;
+  // Send hash of yaml
+
+  if (!boost::filesystem::exists(sconfig.target_name_path) || !boost::filesystem::exists(sconfig.firmware_path)) {
+    *target_name = std::string("noimage");
+    content = "";
+  } else {
+    *target_name = Utils::readFile(sconfig.target_name_path.string());
+    content = Utils::readFile(sconfig.firmware_path.string());
+  }
+  *sha256hash = boost::algorithm::to_lower_copy(boost::algorithm::hex(Crypto::sha256digest(content)));
+  target_len = content.size();
+
+  return true;
+}
+}  // namespace Uptane
\ No newline at end of file
diff --git a/src/libaktualizr/uptane/dockersecondary.h b/src/libaktualizr/uptane/dockersecondary.h
new file mode 100644
index 00000000..ecd39735
--- /dev/null
+++ b/src/libaktualizr/uptane/dockersecondary.h
@@ -0,0 +1,26 @@
+#ifndef UPTANE_DOCKERSECONDARY_H_
+#define UPTANE_DOCKERSECONDARY_H_
+
+#include <string>
+
+#include "uptane/managedsecondary.h"
+#include "utilities/types.h"
+
+namespace Uptane {
+
+/**
+ * An Uptane secondary that runs on the same device as the primary but treats
+ * the firmware that it is pushed as a docker-compose yaml file
+ */
+class DockerComposeSecondary : public ManagedSecondary {
+ public:
+  explicit DockerComposeSecondary(const SecondaryConfig& sconfig_in);
+  ~DockerComposeSecondary() override = default;
+
+ private:
+  bool storeFirmware(const std::string& target_name, const std::string& content) override;
+  bool getFirmwareInfo(std::string* target_name, size_t& target_len, std::string* sha256hash) override;
+};
+}  // namespace Uptane
+
+#endif  // UPTANE_DOCKERSECONDARY_H_
diff --git a/src/libaktualizr/uptane/secondaryconfig.cc b/src/libaktualizr/uptane/secondaryconfig.cc
index 3db57188..80382b26 100644
--- a/src/libaktualizr/uptane/secondaryconfig.cc
+++ b/src/libaktualizr/uptane/secondaryconfig.cc
@@ -18,6 +18,8 @@ SecondaryConfig::SecondaryConfig(const boost::filesystem::path &config_file) {
     secondary_type = Uptane::SecondaryType::kOpcuaUptane;
   } else if (stype == "isotp_uptane") {
     secondary_type = Uptane::SecondaryType::kIsoTpUptane;
+  } else if (stype == "docker_compose") {
+    secondary_type = Uptane::SecondaryType::kDockerCompose;
   } else {
     LOG_ERROR << "Unrecognized secondary type: " << stype;
   }
diff --git a/src/libaktualizr/uptane/secondaryconfig.h b/src/libaktualizr/uptane/secondaryconfig.h
index 63075c35..0414601a 100644
--- a/src/libaktualizr/uptane/secondaryconfig.h
+++ b/src/libaktualizr/uptane/secondaryconfig.h
@@ -25,6 +25,7 @@ enum class SecondaryType {
   kVirtualUptane,  // Partial UPTANE secondary implemented inside primary
   kIsoTpUptane,    // Custom Uptane protocol over ISO/TP network
 
+  kDockerCompose,  // Secondary 'firmware' is a docker-compose image
 };
 
 class SecondaryConfig {
diff --git a/src/libaktualizr/uptane/secondaryfactory.h b/src/libaktualizr/uptane/secondaryfactory.h
index 8bb7f7f2..1c2baf0b 100644
--- a/src/libaktualizr/uptane/secondaryfactory.h
+++ b/src/libaktualizr/uptane/secondaryfactory.h
@@ -4,6 +4,7 @@
 #include "ipuptanesecondary.h"
 #include "isotpsecondary.h"
 #include "logging/logging.h"
+#include "uptane/dockersecondary.h"
 #include "uptane/ipuptanesecondary.h"
 #include "uptane/opcuasecondary.h"
 #include "uptane/secondaryconfig.h"
@@ -37,6 +38,8 @@ class SecondaryFactory {
         LOG_ERROR << "libaktualizr was built without OPC-UA secondary support.";
         return std::shared_ptr<SecondaryInterface>();  // NULL-equivalent
 #endif
+      case SecondaryType::kDockerCompose:
+        return std::make_shared<DockerComposeSecondary>(sconfig);
       default:
         LOG_ERROR << "Unrecognized secondary type: " << static_cast<int>(sconfig.secondary_type);
         return std::shared_ptr<SecondaryInterface>();  // NULL-equivalent
diff --git a/src/libaktualizr/utilities/utils.cc b/src/libaktualizr/utilities/utils.cc
index 964c45f2..94a01743 100644
--- a/src/libaktualizr/utilities/utils.cc
+++ b/src/libaktualizr/utilities/utils.cc
@@ -314,14 +314,15 @@ static ssize_t read_cb(struct archive *a, void *client_data, const void **buffer
   return s->is.gcount();
 }
 
-void Utils::writeFile(const boost::filesystem::path &filename, const std::string &content, bool create_directories) {
+void Utils::writeFile(const boost::filesystem::path &filename, const std::string &content, bool create_directories,
+                      bool atomic) {
   if (create_directories) {
     boost::filesystem::create_directories(filename.parent_path());
   }
-  Utils::writeFile(filename, content.c_str(), content.size());
+  Utils::writeFile(filename, content.c_str(), content.size(), atomic);
 }
 
-void Utils::writeFile(const boost::filesystem::path &filename, const char *content, size_t size) {
+void Utils::writeFile(const boost::filesystem::path &filename, const char *content, size_t size, bool atomic) {
   // also replace the target file atomically by creating filename.new and
   // renaming it to the target file name
   boost::filesystem::path tmpFilename = filename;
@@ -332,13 +333,20 @@ void Utils::writeFile(const boost::filesystem::path &filename, const char *conte
     throw std::runtime_error(std::string("Error opening file ") + tmpFilename.string());
   }
   file.write(content, static_cast<std::streamsize>(size));
+  if (atomic) {
+    sync();
+  }
   file.close();
 
   boost::filesystem::rename(tmpFilename, filename);
+  if (atomic) {
+    sync();
+  }
 }
 
-void Utils::writeFile(const boost::filesystem::path &filename, const Json::Value &content, bool create_directories) {
-  Utils::writeFile(filename, jsonToStr(content), create_directories);
+void Utils::writeFile(const boost::filesystem::path &filename, const Json::Value &content, bool create_directories,
+                      bool atomic) {
+  Utils::writeFile(filename, jsonToStr(content), create_directories, atomic);
 }
 
 std::string Utils::jsonToStr(const Json::Value &json) {
diff --git a/src/libaktualizr/utilities/utils.h b/src/libaktualizr/utilities/utils.h
index 58362230..7e8d523c 100644
--- a/src/libaktualizr/utilities/utils.h
+++ b/src/libaktualizr/utilities/utils.h
@@ -24,11 +24,12 @@ struct Utils {
   static std::string genPrettyName();
   static std::string readFile(const boost::filesystem::path &filename, bool trim = false);
 
-  static void writeFile(const boost::filesystem::path &filename, const char *content, size_t size);
+  static void writeFile(const boost::filesystem::path &filename, const char *content, size_t size,
+                        bool atomic = false);
   static void writeFile(const boost::filesystem::path &filename, const std::string &content,
-                        bool create_directories = true);
+                        bool create_directories = true, bool atomic = false);
   static void writeFile(const boost::filesystem::path &filename, const Json::Value &content,
-                        bool create_directories = true);
+                        bool create_directories = true, bool atomic = false);
   static void copyDir(const boost::filesystem::path &from, const boost::filesystem::path &to);
   static std::string readFileFromArchive(std::istream &as, const std::string &filename, bool trim = false);
   static void writeArchive(const std::map<std::string, std::string> &entries, std::ostream &as);
-- 
2.21.0


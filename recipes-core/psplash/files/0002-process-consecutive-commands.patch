From d8cd513e75f0fee42d8cd7c796ae8953c2bf4220 Mon Sep 17 00:00:00 2001
From: Stefan Agner <stefan.agner@toradex.com>
Date: Tue, 19 Feb 2019 19:20:17 +0100
Subject: [PATCH 2/3] process consecutive commands

Process consecutive commands separated by null-termations. Since
it is a FIFO, in theory, those can be from two independent calls
to psplash-write. While at it, make the command parser more
robust. With this code, sequences like this get parsed just fine:
  echo -e "\nPROGRESS 10\n\0\nQUIT" > /run/psplash_fifo

Signed-off-by: Stefan Agner <stefan.agner@toradex.com>
---
 psplash.c | 50 ++++++++++++++++++++++++++++++++++----------------
 1 file changed, 34 insertions(+), 16 deletions(-)

diff --git a/psplash.c b/psplash.c
index 169f9c1..b40adf2 100644
--- a/psplash.c
+++ b/psplash.c
@@ -115,11 +115,17 @@ parse_command (PSplashFB *fb, char *string)
 
   if (!strcmp(command,"PROGRESS")) 
     {
-      psplash_draw_progress (fb, atoi(strtok(NULL,"\0")));
+      char *arg = strtok(NULL, "\0");
+
+      if (arg)
+        psplash_draw_progress (fb, atoi(arg));
     } 
   else if (!strcmp(command,"MSG")) 
     {
-      psplash_draw_msg (fb, strtok(NULL,"\0"));
+      char *arg = strtok(NULL, "\0");
+
+      if (arg)
+        psplash_draw_msg (fb, arg);
     } 
   else if (!strcmp(command,"QUIT")) 
     {
@@ -137,6 +143,7 @@ psplash_main (PSplashFB *fb, int pipe_fd, int timeout)
   fd_set         descriptors;
   struct timeval tv;
   char          *end;
+  char          *cmd;
   char           command[2048];
 
   tv.tv_sec = timeout;
@@ -172,21 +179,32 @@ psplash_main (PSplashFB *fb, int pipe_fd, int timeout)
 	  pipe_fd = open(PSPLASH_FIFO,O_RDONLY|O_NONBLOCK);
 	  goto out;
 	}
-      
-      if (command[length-1] == '\0') 
-	{
-	  if (parse_command(fb, command))
-	    return;
-	  length = 0;
-	} 
-      else if (command[length-1] == '\n') 
-	{
-	  command[length-1] = '\0';
-	  if (parse_command(fb, command))
-	    return;
-	  length = 0;
-	} 
 
+      cmd = command;
+      do {
+	int cmdlen;
+        char *cmdend = memchr(cmd, '\n', length);
+
+        /* Replace newlines with string termination */
+        if (cmdend)
+            *cmdend = '\0';
+
+        cmdlen = strnlen(cmd, length);
+
+        /* Skip string terminations */
+	if (!cmdlen && length)
+          {
+            length--;
+            cmd++;
+	    continue;
+          }
+
+	if (parse_command(fb, cmd))
+	  return;
+
+	length -= cmdlen;
+	cmd += cmdlen;
+      } while (length);
 
     out:
       end = &command[length];
-- 
2.20.1

